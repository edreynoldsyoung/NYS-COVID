---
title: "New York State COVID-19"
author: "Ed Young"
date:  '`r format(Sys.Date(), "%B %d, %Y")`'
output:
  html_document:
    css: styles.css
    highlight: null
    theme: null
  df_print: kable
  pdf_document: default
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
     echo = FALSE,
     warning = FALSE,
     message = FALSE,
     cache = FALSE
)

## required install on system (sudo apt install ...):  libgdal-dev, libudunits2-dev, libcurl4-openssl-dev
## Census API Key is required:  http://api.census.gov/data/key_signup.html
## Once acquired, the Census API Key should be included in #HOME/.Renviron file
## First line in file should be:  CENSUS_API_KEY = 'ID'
check_load_pkgs <- function() {
  # List of packages to check and possibly install
  packages <- c("tidyverse", "ggrepel", "lubridate", "EpiEstim", "RSocrata", 
                "knitr", "sf", "tigris", "usmap", "tidycensus", 
                "scales", "viridis", "ggridges")
  
  # Loop through each package to check if it is installed
  for (pkg in packages) {
    if (!requireNamespace(pkg, quietly = TRUE)) {
      message(paste("installing the '", pkg, "' package", sep = ""))
      
      # Error handling for installation
      tryCatch(
        {
          install.packages(pkg, Ncpus = parallel::detectCores())
        },
        error = function(e) {
          message(paste("Failed to install ", pkg, ": ", e, sep = ""))
        }
      )
    }
  }
}

# Run the function to check and install packages
check_load_pkgs()

# Options related to tigris package
# These options set tigris to use 'sf' class and enable caching
options(tigris_class = "sf")
options(tigris_use_cache = TRUE)

## Download latest NY State data from health.data.ny.gov
## Munge

# Function to read and process NYS health data
read_process_nys_data <- function() {
  # Error handling for API call
  nys_data <- tryCatch(
    {
      read.socrata("https://health.data.ny.gov/resource/xdss-u53e.json")
    },
    error = function(e) {
      message("Failed to read data: ", e)
      return(NULL)
    }
  )
  
  if (is.null(nys_data)) return(NULL)
  
  # Data transformation
  nys_cleaned <- nys_data %>%
    select(
      t = test_date,
      I = new_positives,
      C = cumulative_number_of_positives,
      T = total_number_of_tests,
      county
    ) %>%
    filter(!county %in% c("Capital Region", "Central New York", "Finger Lakes", 
                          "Long Island", "Mid-Hudson", "Mohawk Valley", 
                          "New York City", "North Country", "Out-of-State", 
                          "STATEWIDE", "Southern Tier", "Western New York")) %>%
    mutate(
      t = as.Date(t),
      I = as.integer(I),
      C = as.integer(C),
      T = as.integer(T),
      f = fips("NY", county = county)
    ) %>%
    arrange(f, t)
  
  return(nys_cleaned)
}

# Read and process data
nys <- read_process_nys_data()

# State-level aggregation
if (!is.null(nys)) {
  state <- nys %>%
    group_by(t) %>%
    summarise(
      SI = sum(I, na.rm = TRUE),
      SC = sum(C, na.rm = TRUE),
      ST = sum(T, na.rm = TRUE)
    )
}

## Download latest national data at State level from New York Times
## Munge

# Function to download and preprocess data
download_and_process_data <- function() {
  # Error handling for data download
  cases_data <- tryCatch(
    {
      readr::read_csv("https://raw.githubusercontent.com/nytimes/covid-19-data/master/us-states.csv")
    },
    error = function(e) {
      message("Failed to download data: ", e)
      return(NULL)
    }
  )
  
  # Return NULL if download failed
  if (is.null(cases_data)) return(NULL)
  
  # Data preprocessing
  cases_processed <- cases_data %>%
    filter(fips < 60) %>%
    mutate(
      date = as.Date(date),
      state = as.character(state),
      f = as.character(as.numeric(fips))
    ) %>%
    arrange(f, date) %>%
    # Calculate incremental cases
    group_by(f) %>%
    mutate(I = if_else(
      cases - lag(cases, n = 1, default = 0) > 0,
      cases - lag(cases, n = 1, default = 0),
      0
    )) %>%
    ungroup()
  
  return(cases_processed)
}

# Download and process data
Cases2 <- download_and_process_data()

## Download data on deaths at County level from NY Times
## Munge

# Function to download and preprocess data
download_and_process_death_data <- function() {
  # Error handling for data download
  deaths_data <- tryCatch(
    {
      readr::read_csv("https://raw.githubusercontent.com/nytimes/covid-19-data/master/us-counties.csv")
    },
    error = function(e) {
      message("Failed to download data: ", e)
      return(NULL)
    }
  )
  
  # Return NULL if download failed
  if (is.null(deaths_data)) return(NULL)
  
  # Data preprocessing
  deaths_processed <- deaths_data %>%
    mutate(
      date = as.Date(date),
      county = as.character(county),
      state = as.character(state)
    )
  
  return(deaths_processed)
}

# Download and process data
USDeaths <- download_and_process_death_data()

# Aggregate data for New York State
NYDeaths <- USDeaths %>%
  filter(state == "New York") %>%
  group_by(date) %>%
  summarise(SD = sum(deaths, na.rm = TRUE)) %>%
  mutate(d = SD - lag(SD, n = 1, default = 0)) %>%
  ungroup()

# Aggregate data for counties in New York State
NYCountyDeaths <- USDeaths %>%
  filter(state == "New York" & county != "Unknown") %>%
  select(county, date, deaths) %>%
  group_by(county) %>%
  arrange(county, date) %>%
  mutate(d = deaths - lag(deaths, n = 1, default = 0)) %>%
  ungroup()

# Download US State map data
United_States_map <- tryCatch({
  states() %>%
    filter(STATEFP < 60) %>%  # Filter out non-state regions
    mutate(f = as.character(STATEFP)) %>%  # Convert STATEFP to character
    select(f, STUSPS)  # Select relevant columns
}, error = function(e) {
  message("Failed to download United States map data: ", e)
  NULL
})

# Download New York County map data
ny_map <- tryCatch({
  counties(state = 36) %>%  # Filter for New York state (FIPS code 36)
    mutate(f = paste0(STATEFP, COUNTYFP)) %>%  # Create full FIPS code
    select(GEOID, County = NAME, f)  # Select relevant columns
}, error = function(e) {
  message("Failed to download New York County map data: ", e)
  NULL
})

# Download and process New York county population data
NYpop <- tryCatch({
  get_acs(geography = "county",
          state = 36,
          variables = "B01003_001") %>%
    select(GEOID, "Population" = estimate)  # Rename 'estimate' to 'Population'
}, error = function(e) {
  message("Failed to download New York county population data: ", e)
  return(NULL)
})

# Download and process U.S. state population data
USpop <- tryCatch({
  get_acs(geography = "state",
          variables = "B01003_001") %>%
    filter(GEOID < 60) %>%
    mutate(f = as.character(GEOID)) %>%  # Convert GEOID to character
    select(f, "State" = NAME, "Population" = estimate)  # Rename columns
}, error = function(e) {
  message("Failed to download U.S. state population data: ", e)
  return(NULL)
})



## Calculate Rt using the EpiEstim Package for New York State
## The window for estimating Rt can be adjusted using t_start and t_end.
## The default setting for the window is 7 days


R.instantaneous <- estimate_R(state$SI,
                              method = "parametric_si",
                              config = list(mean_si = 3.96,
                                            std_si = 4.75))

###### Setup for estimating Rt

## 1. Start with a data.frame that has the following columns: fips, date, incidence
## 2. Obtain the unique list of fips (lof) for which you want to calculate Rt
## 3. Iterate over the list of fips, obtain the list of incidence for each fips
## 4. Use the estimate_R function to estimate R and it's std for each fips
## 5. Assign those values to an ROutput data.frame


makeRoutput <- function(df, tn) {
     lof <-
          df %>% select(f) %>% unique() %>% filter(!is.na(f)) %>% as.list()
     ROutput <- tibble(
          f = lof$f,
          R = 0,
          Std = 0,
          Confl = 0,
          Confh = 0
     )
     for (fips in lof$f) {
          x <- df %>% filter(f == fips, !is.na(I)) %>% select(I) %>% sum()
          y <-
               df %>% filter(f == fips, !is.na(I)) %>% select(I) %>% lengths()
          if (x * 7 / y > 11) {
               t_start <- seq(2, y - tn)
               t_end <- t_start + tn
               R0 <- estimate_R(
                    incid = df %>% filter(f == fips, !is.na(I)) %>% select(I),
                    method = "parametric_si",
                    config = make_config(
                         list(
                              mean_si = 3.96,
                              std_si = 4.75,
                              t_start = t_start,
                              t_end = t_end
                         )
                    )
               )
               n <- length(R0$R$t_start)
               std <- round(R0$R$'Std(R)'[n], 3)
               R <- round(R0$R$'Mean(R)'[n], 3)
               ROutput$R[ROutput$f == fips] <- R
               ROutput$Std[ROutput$f == fips] <- std
               ROutput$Confl[ROutput$f == fips] <-
                    R - 1.96 * std / sqrt(n)
               ROutput$Confh[ROutput$f == fips] <-
                    R + 1.96 * std / sqrt(n)
          } else {
               ROutput$R[ROutput$f == fips] <- NA
               ROutput$Std[ROutput$f == fips] <- NA
               ROutput$Confl[ROutput$f == fips] <- NA
               ROutput$Confh[ROutput$f == fips] <- NA
          }
     }
     return(ROutput)
}

ROutput.NY <- makeRoutput(nys, 7)
ROutput.US <- makeRoutput(Cases2, 7)

#####################################################################################
# Calculate the Effect Size of an intervention by noting the difference between the
# predicted value from the regression line before the intervention, and the value
# from the regression line after the intervention at the same point after the
# intervention.

 forNYS <- nys %>%
     group_by(county) %>%
     filter(max(I) > 100)

 forNYS$I[forNYS$I == 0] <- NA

 clength <- length(unique(forNYS$county))
 CSD <- tibble(
     "County" = unique(forNYS$county),
     "countyFIPS" = forNYS$f,
     b = rep.int(0, clength),
     a = rep.int(0, clength),
     d = rep.int(0, clength),
     g = rep.int(0, clength),
     h = rep.int(0, clength),
     y_int1 = rep.int(0, clength),
     y_int2 = rep.int(0, clength),
     y_int3 = rep.int(0, clength)
 )
# for (c in unique(forNYS$county)) {
#     x <-
#          lm(log10(I) ~ t, data = filter(forNYS, t <= as.Date("2020-03-20") &
#                                              county == c), na.action=na.omit)
#     y <-
#          lm(log10(I) ~ t, data = filter(forNYS, t >= as.Date("2020-04-03") & t <= as.Date("2020-06-01") &
#                                              county == c), na.action=na.omit)
#     y2 <- lm(log10(I) ~ t, data = filter(forNYS, t >= as.Date("2020-06-01") &
#                                              county == c), na.action=na.omit)
#     z <-
#          10 ^ (predict(x, data.frame(t = as.Date("2020-04-03")))) - 10 ^ y$fitted.values[1]
#     CSD$b[CSD$County == c] <- 10^x$coefficients[2]
#     CSD$a[CSD$County == c] <- 10^y$coefficients[2]
#     CSD$d[CSD$County == c] <- 10^(x$coefficients[2] - y$coefficients[2])
#     CSD$g[CSD$County == c] <- z
#     CSD$h[CSD$County == c] <- 10^y2$coefficients[2]
#     CSD$y_int1[CSD$County == c] <- 10^tail(x$fitted.values, 1)
#     CSD$y_int2[CSD$County == c] <- 10^(tail(x$fitted.values, 1)+14*x$coefficients[2])
#     CSD$y_int3[CSD$County == c] <- 10^y$model$`log10(I)`[1]
# }

# CSD <- CSD %>%
#     arrange(desc(g)) %>%
#     mutate(
#          "SlopeBefore" = round(b, 3),
#          "SlopeAfter" = round(a, 3),
#          "SlopeDiff" = round(d, 3),
#          "EffectSize" = round(g, 0),
#          "SlopeOpen" = round(h, 3),
#          "countyFIPS" = fips("NY", county = County)
#     ) %>%
#     select(
#          County,
#          "countyFIPS",
#          "SlopeBefore",
#          "SlopeAfter",
#          "SlopeDiff",
#          "EffectSize",
#          "SlopeOpen",
#          y_int1,
#          y_int2,
#          y_int3
#     )

 forNYS <- forNYS %>% 
     inner_join(CSD, by = c("county"="County"))

#####################################################
# Joining data from Map, Census, and Rt estimation

ny_map3 <- ny_map %>%
     inner_join(ROutput.NY, by = "f") %>%
     inner_join(NYpop, by = "GEOID")

ny_map4 <- ny_map3 %>%
     as_tibble() %>%
     arrange(County) %>%
     select(County,
            R,
            Confl,
            Confh,
            "Population" = estimate)

us_map <- ROutput.US %>%
     inner_join(United_States_map, by = "f") %>%
     inner_join(USpop, by = "f")

us_map48 <- us_map %>%
     filter(!(
          State %in% c("Alaska", "District of Columbia", "Hawaii", "Puerto Rico")
     ))

us_map4 <- us_map48 %>%
     arrange(State) %>%
     select(State,
            R,
            Confl,
            Confh,
            Population) %>%
     tibble()

###########################################################
# Barrier-free color palette
# Source: Okabe & Ito (2008): Color Universal Design (CUD):
#         Fig. 16 of <https://jfly.uni-koeln.de/color/>:

# (a) Vector of colors (as RGB values):
o_i_colors <- c(
     rgb(0,   0,   0, maxColorValue = 255),
     # black
     rgb(230, 159,   0, maxColorValue = 255),
     # orange
     rgb(86, 180, 233, maxColorValue = 255),
     # skyblue
     rgb(0, 158, 115, maxColorValue = 255),
     # green
     rgb(240, 228,  66, maxColorValue = 255),
     # yellow
     rgb(0, 114, 178, maxColorValue = 255),
     # blue
     rgb(213,  94,   0, maxColorValue = 255),
     # vermillion
     rgb(204, 121, 167, maxColorValue = 255)   # purple
)

# (b) Vector of color names:
o_i_names <-
     c("black",
       "orange",
       "skyblue",
       "green",
       "yellow",
       "blue",
       "vermillion",
       "purple")

names(o_i_colors) <- o_i_names

###########################################################
# Themes

plot_theme <- theme(
  plot.background = element_rect(fill = "linen"),
  plot.title = element_text(face="bold", size=rel(1.5), hjust=0),
  plot.subtitle = element_text(),
  panel.background = element_rect(fill = "linen"),
  axis.line = element_line(color = "black"),
  legend.background = element_rect(fill = "linen")
)

double_axis_theme <-   theme(
    plot.background = element_rect(fill = "linen"),
    plot.title = element_text(face="bold", 
      size=rel(1.5), 
      hjust=0
      ),
    plot.subtitle = element_text(color = "tomato"), 
    panel.background = element_rect(fill = "linen"),  
    axis.title.y.left = element_text(color = "blue"),
    axis.title.y.right = element_text(color = "tomato"),
    axis.text.y.right = element_text(color = "tomato"),
    axis.line.x = element_line(color = "black"),
    axis.line.y.left = element_line(color = "black"),
    axis.line.y.right = element_line(color = "tomato")
  ) 

facet_theme <- theme(
          plot.background = element_rect(fill = "linen"),
          plot.title = element_text(face="bold", size=rel(1.5), hjust=0),
          plot.subtitle = element_text(),
          panel.background = element_rect(fill = "linen"),
          panel.border = element_rect(
            colour = "black",
            fill = NA,
            size = 1
            ),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          strip.background = element_rect(fill = "linen"),
          strip.text = element_text(color = "black"),
          legend.position = "bottom"
     )

map_theme <- theme(
          rect = element_rect(fill = "linen"),
          plot.background = element_rect(fill = "linen", color = "linen"),
          panel.background = element_rect(fill = "linen", color = "linen"),
          legend.background = element_rect(fill = "linen"),
          axis.title = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          plot.title = element_text(face="bold", size=rel(1.5), hjust=0),
          plot.subtitle = element_text()    
     )   
```


<p class="intro">This page is based on data from <a aria-describedby="footnote-label" href="#D1">New York State Department of Health</a>, most recently updated on `r max(nys$t)`; and on data from <a aria-describedby="footnote-label" href="#D2">The New York Times</a>, most recently updated on `r max(NYDeaths$date)`.</p>

The first set of graphs represent new cases of COVID-19 for the state of New York.  Following are graphs and figures representing the same information broken down by county in New York.

Because of the latency from time of infection to symptoms, and then to diagnosis, it may take up to 14 days after a change in policy for the number of new cases to decrease.  I have indicated this two week period after the policy of social distancing enforcement with gray dots.  Regression lines before and after the policy omit that two week period. 

The effect size of interventions such as sheltering at home, social distancing, and wearing masks can be measured in two ways.  The first, and most intuitive, is to produce two regression lines based on the data before the interventions, and after the interventions.  The first regression line represents the rate of infection before any interventions were made.  We can extend that line through the two week intervention period, and estimate the number of infections that would have been expected if no interventions had taken place.  Then we can measure the distance from that counterfactual predicted value to the factual number of infections based on the data after the intervention.  This gives an estimation of the difference between what the number of infections might have been without an intervention, and the actual number with an intervention - that is, the effect size of the intervention.  A second, more abstract, way is to compare the slopes of the two regression lines.  Although this is a measurement of the intervention, it is not intuitively clear what that change in slope represents.

These charts are for demonstration purposes only.  The regression lines are drawn using simple linear regression, rather than an ARIMA model, which is more appropriate for time series.  In addition, there may be other factors beside the social distancing intervention that may have influenced the change in regression lines during this period.  For example, the natural history of infections may have an increasing phase and decreasing phase without any intervention. However, the fact that we see a marked change at the precise time that social distancing was enforced is strong evidence that it was that intervention which caused the change.

The most recent measurement on each graph is labeled in red.


# New York State Cases

```{r NYS New}
ggplot(data = state) +
  geom_point(mapping = aes(x = t, y = SI)) +
  geom_point(data = filter(state, t == max(t)),
             mapping = aes(x = t, y = SI),
             color = "red") +  
  geom_label_repel(
    data = filter(state, t == max(t)),
    aes(
      x = t,
      y = SI,
      label = sprintf("%i", SI),
      fill="red"
    ),
    show.legend = FALSE,
    segment.color = "black",
    nudge_x = -10,
    nudge_y = 50
  ) +
  geom_vline(xintercept = as.Date("2020-03-20"), linetype = 4) +
  geom_rect(
    aes(
      xmin = as.Date("2020-03-20"),
      xmax = as.Date("2020-04-03"),
      ymin = 0,
      ymax = Inf
    ),
    fill = "gray100",
    alpha = 0.01
  ) +
  geom_label(label = "Social Distancing Enforced",
             x = as.Date("2020-03-20"),
             y = max(state$SI))  +
  labs(x = "Date",
       y = "New Cases per Day") +
  ggtitle(label = "New York State - New Cases", subtitle = "Natural Scale") +
  plot_theme
  

state1 <- state
state1$SI[state1$SI == 0] <- 1
before <-
  lm(log10(SI) ~ t, data = filter(state1, t <= as.Date("2020-03-20")))
after1 <-
  lm(log10(SI) ~ t, data = filter(state, t >= as.Date("2020-04-03") & t<= as.Date("2020-06-01")))
after2 <-
  lm(log10(SI) ~ t, data = filter(state, t> as.Date("2020-06-01")))
ggplot(data = state) +
  geom_point(mapping = aes(x = t, y = SI)) +
  geom_point(data = filter(state, t == max(t)),
             mapping = aes(x = t, y = SI),
             color = "red") +  
  geom_smooth(
    data = filter(state, t <= as.Date("2020-03-20")),
    mapping = aes(x = t, y = SI),
    colour = "red",
    method = lm,
    na.rm = TRUE,
    se = FALSE
  ) +
  geom_smooth(
    data = filter(state, t >= as.Date("2020-04-03") & t<=as.Date("2020-06-01")),
    mapping = aes(x = t, y = SI),
    colour = "green",
    method = lm,
    na.rm = TRUE,
    se = FALSE
  ) +
  geom_smooth(
    data = filter(state, t>=as.Date("2020-06-01")),
    mapping = aes(x = t, y = SI),
    colour = "yellow",
    method = lm,
    na.rm = TRUE,
    se = FALSE
  ) +
  geom_segment(
    aes(
      x = as.Date("2020-03-20"),
      y = 10 ^ before$model$`log10(SI)`[18],
      xend = as.Date("2020-04-03"),
      yend = 10 ^ (before$model$`log10(SI)`[18] + 14 * before$coefficients[2]),
    ),
    linetype = 2,
    color = "red",
    show.legend = NA
  ) +
  geom_segment(
    aes(
      x    = as.Date("2020-04-03"),
      y    = 10 ^ (before$model$`log10(SI)`[18] + 14 * before$coefficients[2]),
      xend = as.Date("2020-04-03"),
      yend = 10 ^ after1$model$`log10(SI)`[1]
    ),
    linetype = 2,
    color = "black",
    show.legend = NA
  ) +
  geom_rect(
    aes(
      xmin = as.Date("2020-03-20"),
      xmax = as.Date("2020-04-03"),
      ymin = 0,
      ymax = Inf
    ),
    fill = "gray100",
    alpha = 0.01
  ) +
  geom_label_repel(
    data = filter(state, t == max(t)),
    aes(
      x = t,
      y = SI,
      label = sprintf("%i", SI),
      fill="red"
    ),
    show.legend = FALSE,
    segment.color = "black",
    nudge_x = -10,
    nudge_y = 1
  ) +
  geom_vline(xintercept = as.Date("2020-03-20"), linetype = 4) +
  geom_label(label = "Social Distancing Enforced",
             x = as.Date("2020-03-20"),
             y = 0) +
  geom_vline(xintercept = as.Date("2020-06-01"), linetype = 4) +
  geom_label(label = "Opening Begins",
             x = as.Date("2020-06-01"),
             y = 0) +
  geom_text(
    aes(
      label = sprintf(
              "Difference in Slope = %.3f",
              before$coefficients[2] - after1$coefficients[2]
              ),
      x = as.Date("2020-04-05"),
      y = 50000
    ), 
    hjust=0
  ) +
  geom_text(
    aes(
      label = sprintf(
        "Effect Size = %.0f",
        10 ^ (before$model$`log10(SI)`[18] + 14 * before$coefficients[2]) - 10 ^
        after1$model$`log10(SI)`[1]
      ),
    x = as.Date("2020-04-05"),
    y = 100000
    ), hjust=0
    ) +
  geom_text(
    aes(
      label = sprintf(
              "Slope = %.3f",
              after2$coefficients[2]
              ),
      x = as.Date("2020-06-03"),
      y = 100000
    ), 
    hjust=0
  ) +  
  labs(x = "Date",
       y = "New Cases per Day") +
  scale_y_log10(limits = c(1, 2000000), labels = comma) +
  ggtitle(label = "New York State - New Cases", subtitle = "Log Scale") +
  plot_theme
```

\pagebreak

# Cummulative Cases

<p class="intro">The total number of confirmed cases in New York State represents `r round(state$SC[state$t == max(state$t)]/193781, 1)`% of the population.</p>

```{r NYS Cummulative}
ggplot(data = state) +
  geom_point(mapping = aes(x = t, y = SC)) +
  geom_rect(
    aes(
      xmin = as.Date("2020-03-20"),
      xmax = as.Date("2020-04-03"),
      ymin = 0,
      ymax = Inf
    ),
    fill = "gray100",
    alpha = 0.01
  ) +
  geom_point(data = filter(state, t == max(t)),
             mapping = aes(x = t, y = SC),
             color = "red") +
  geom_label_repel(
    data = filter(state, t == max(t)),
    aes(
      x = t,
      y = SC,
      label = sprintf("%i", SC),
      fill="red"
    ),
    show.legend = FALSE,
    segment.color = "black",
    nudge_x = -10,
    nudge_y = -1
  ) +
  labs(x = "Date",
       y = "Log Scale of Cummulative Cases") +
  scale_y_log10(breaks = c(10, 100, 1000, 10000, 100000),
                labels = comma) +
  geom_vline(xintercept = as.Date("2020-03-20"), linetype = 4) +
  geom_label(label = "Social Distancing Enforced",
             x = as.Date("2020-03-20"),
             y = 1) +
  ggtitle(label = "Cummulative: New York State New Cases", subtitle = "Log Scale") +
  plot_theme
```

\pagebreak

# Percentage of Tests that were Positive

<p class="intro">The raw number of positive tests per day can vary depending on how many tests were performed on that day.  One way to normalize this variation is to look at the percentage of tests performed that were positive rather than the raw number of positive tests.</p>

```{r NYS Percentage}
ggplot(data = state) +
  geom_point(mapping = aes(x = t, y = SI * 100 / ST)) +
  geom_point(data = filter(state, t == max(t)),
             mapping = aes(x = t, y = SI*100/ST),
             color = "red") +  
  geom_rect(
    aes(
      xmin = as.Date("2020-03-20"),
      xmax = as.Date("2020-04-03"),
      ymin = 0,
      ymax = Inf
    ),
    fill = "gray100",
    alpha = 0.01
  ) +
  geom_smooth(mapping = aes(x = t, y = SI * 100 / ST),
              method = "gam") +
  geom_label_repel(
    data = filter(state, t == max(t)),
    aes(
      x = t,
      y = SI * 100 / ST,
      label = sprintf("%.1f %%", SI * 100 / ST),
      fill = "red"
    ),
    show.legend = FALSE,
    segment.color = "black",
    nudge_x = -20,
    nudge_y = 50
  ) +
  geom_ribbon(aes(
    ymin = 0,
    ymax = ST / 500,
    x = t,
    fill = ST
  ),
  alpha = 0.3,
  fill = "tomato") +
  scale_y_continuous(sec.axis = sec_axis(~ . * 500, name = "Total Tests Performed")) +
  geom_vline(xintercept = as.Date("2020-03-20"), linetype = 4) +
  geom_label(label = "Social Distancing Enforced",
             x = as.Date("2020-03-20"),
             y = -5) +
  labs(x = "Date",
       y = "Percentage of Tests Performed that were Positive") +
  double_axis_theme +
  ggtitle(label = "Precentage Positive: New York State New Tests", subtitle = "Number of Tests Performed")
```
\pagebreak

# Deaths in New York State

```{r NYS Deaths}
ggplot(data = NYDeaths) +
     geom_point(mapping = aes(x = date, y = d)) +
     geom_point(data = filter(NYDeaths, date == max(date)),
             mapping = aes(x = date, y = d),
             color = "red") +  
     geom_label_repel(
          data = filter(NYDeaths, date == max(date)),
          aes(
               x = date,
               y = d,
               label = sprintf("%i", d),
               fill = "red"
          ),
          show.legend = FALSE,
          segment.color = "black",
          nudge_x = -10,
          nudge_y = -40
     ) +
     geom_smooth(mapping = aes(x = date, y = d),
                 method = "gam") +
     labs(x = "Date",
          y = "Deaths") +
     plot_theme +
     ggtitle(label = "Deaths per Day", subtitle = "Natural Scale")

ggplot(data = NYDeaths) +
     geom_point(mapping = aes(x = date, y = SD)) +
     geom_point(data = filter(NYDeaths, date == max(date)),
             mapping = aes(x = date, y = SD),
             color = "red") +
     scale_y_log10() +
     geom_label_repel(
          data = filter(NYDeaths, date == max(date)),
          aes(
               x = date,
               y = SD,
               label = sprintf("%i", SD),
               fill="red"
          ),
          show.legend = FALSE,
          segment.color = "black",
          nudge_x = -10,
          nudge_y = -1
     ) +
     labs(x = "Date",
          y = "Deaths") +
     plot_theme +
     ggtitle(label = "Cummulative Deaths", subtitle = "Log Scale")
```

# Estimation of R~t~ in New York State as a whole

<p class="intro">Transmissibility of a virus during an epidemic can be measured by the reproduction number R<sub>t</sub>, the average number of secondary infections caused by a primary infected <a aria-describedby="footnote-label" href="#R"> individual</a>.  Statistical methods to estimate R<sub>t</sub> have been developed which require only case incidence data and the distribution of the serial interval (the time between the onset of symptoms in the primary case and the onset of symptoms in the secondary cases). The distribution of the serial interval (mean and standard deviation) can be estimated by directly interviewing people who have been <a aria-describedby="footnote-label" href="#SI">infected</a>.  So long as some new infections continue to occur R<sub>t</sub> will be greater than 0.  If R<sub>t</sub> is less than 1 (each infected individual causes less than one other person to become infected, on average), we would expect the number of new cases each day to be less than the day before.  If R<sub>t</sub> is greater than 1, we would expect the number of new cases to grow.</p> 

The estimate of the most recent R<sub>t</sub> for the State of New York is <b> `r round(R.instantaneous$R$'Mean(R)'[length(R.instantaneous$R$t_start)], 3)` </b>
The 95% Confidence interval around this estimate is quite narrow, and can't be seen clearly given the scale of the graph.  A Histogram of the estimates of R<sub>t</sub> at the most recent point is given below.

```{r NYS R Plot}
estimate_R_plots(
     R.instantaneous,
     what = "R",
     options_R = list(xlab = "Days Since First Reported Infection"),
     legend = TRUE
)

R.sample <-
sample_posterior_R(R.instantaneous,
n = 1000,
window = length(R.instantaneous$R$t_start))
hist(R.sample)
```
\pagebreak

# Number of New Cases by County

<p class="intro">I have only run scatter plots and regression lines on those counties that had more than 100 new cases on at least one day. For the other counties, I have represented their data using heat maps and ridgeline plots.</p>

As a reminder, New York City is divided into five boroughs, each borough being its own county.  Manhattan is New York County, the Bronx is Bronx County, Queens is Queens County, Brooklyn is Kings County, and Staten Island is Richmond County. 

```{r County New 1,  fig.height=20, fig.width=20}
ggplot(data = forNYS) +
     geom_point(mapping = aes(x = t, y = I)) +
     geom_point(data = filter(forNYS, t == max(t)),
             mapping = aes(x = t, y = I),
             color = "red") +
#     geom_rect(
#          aes(
#               xmin = as.Date("2020-03-20"),
#               xmax = as.Date("2020-04-03"),
#               ymin = 0,
#               ymax = Inf
#          ),
#          fill = "gray100",
#          alpha = 0.01
#     ) +
     labs(x = NULL,
          y = "New Cases per Day") +
     scale_y_log10(labels = comma) +
#     geom_vline(xintercept = as.Date("2020-03-20"), linetype = 4) +
#     geom_vline(xintercept = as.Date("2020-06-01"), linetype = 4) + 
     geom_label_repel(
          data = filter(forNYS, t == max(t)),
          aes(
               x = t,
               y = I,
               label = sprintf("%i", I),
               fill="red"
          ),
          show.legend = FALSE,
          segment.color = "black",
          nudge_x = -10,
          nudge_y = 1
     ) +
#     geom_smooth(
#          data = filter(forNYS, t <= as.Date("2020-03-20")),
#          mapping = aes(x = t, y = I),
#          colour = "red",
#          method = lm,
#          na.rm = TRUE,
#          se = FALSE
#     ) +
#     geom_smooth(
#          data = filter(forNYS, t >= as.Date("2020-04-03") & t <= as.Date("2020-06-01")),
#          mapping = aes(x = t, y = I),
#          colour = "green",
#          method = lm,
#          na.rm = TRUE,
#          se = FALSE
#     ) +
#     geom_smooth(
#          data = filter(forNYS, t >= as.Date("2020-06-01")),
#          mapping = aes(x = t, y = I),
#          colour = "yellow",
#          method = lm,
#          na.rm = TRUE,
#          se = FALSE
#     ) +
#     geom_segment(
#          aes(
#               x = as.Date("2020-03-20"),
#               y = y_int1,
#               xend = as.Date("2020-04-03"),
#               yend = y_int2
#          ),
#          linetype = 2,
#          color = "red",
#          show.legend = NA
#     ) +
#     geom_segment(
#          aes(
#               x    = as.Date("2020-04-03"),
#               y    = y_int2,
#               xend = as.Date("2020-04-03"),
#               yend = y_int3
#          ),
#          linetype = 2,
#          color = "black",
#          show.legend = NA
#     ) +
#     geom_text(
#          aes(
#               label = sprintf("Effect Size is %.0f", EffectSize),
#               x = as.Date("2020-04-05"),
#               y = 100000
#               ),
#          hjust=0
#          ) +
 #    geom_text(
 #         aes(
 #              label = sprintf("Difference in Slope is %.3f", SlopeDiff),
 #              x = as.Date("2020-04-05"),
 #              y = 50000
 #              ),
 #         hjust=0
 #         ) +
#     geom_text(
#          aes(
#               label = sprintf("Slope is %.3f", SlopeOpen),
#               x = as.Date("2020-06-05"),
#               y = 100000
#               ),
#          hjust=0
#          ) +  
     facet_wrap(vars(county), ncol = 4) +
     facet_theme +
     ggtitle(label="New Cases by County", subtitle = "Counties with a maximum of over 100 New Cases on a single day")
```

# Effect Size

<p class="intro">The Effect Size is the estimated number of lives saved by actions such as sheltering at home, social distancing, and wearing masks.  Note that the greatest changes in the Effect Size are in the largest and heaviest hit counties.</p>


# ```{r County Slope Difference, fig.width=7.5, fig.height=7.5}
# CSD %>%
#  inner_join(NYpop, by = c("countyFIPS" = "GEOID")) %>%
#  ggplot(
#  aes(
#    y=fct_reorder(County, EffectSize/estimate),
#    x = EffectSize/estimate,
#    size = estimate,
#    color = estimate)
#  ) +
# geom_point() +
# annotate(
#  geom = "rect",
#  xmin = c(0, 0.05, .1, .15),
#  xmax = c(0.05, .1, .15, .2),
#  ymin = -Inf,
#  ymax = Inf,
#  fill = c(o_i_colors[1:4]),
#  alpha = 0.1) +
# scale_color_viridis_c() +
# scale_x_continuous(
#  labels = percent,
#  limits = c(0, 0.2)) +
# guides(
#  color = guide_legend(title = "Population"),
#  size = guide_legend(title = "Population")
#  ) +
# labs(
#  x="Effect Size as percent of Population",
#  y=NULL) +
# ggtitle(label = "Social Distancing Effect Size by County", subtitle = "Counties with more than 100 cases in a day") +
# plot_theme
# ```

# <p class="intro">However, even though the relation between Effect size and Population Size does appear linear, there is a large amount of variance that has not  been explained.</p>

```{r Effect Size vs. Population, fig.width=7.5, fig.height=5}
 data1 <- CSD %>%
  inner_join(NYpop, by = c("countyFIPS" = "GEOID"))

 data2 <- CSD %>%
  inner_join(NYpop, by = c("countyFIPS" = "GEOID")) %>%
  filter(estimate > 1000000)

 ggplot(
    data1,
    aes(
      y = EffectSize,
      x = estimate)
    ) +
  geom_point() +
  geom_smooth(method = lm) +
  geom_label_repel(
    data = data2,
    mapping = aes(
      y = EffectSize,
      x = estimate,
      label = County
    ),
    show.legend = FALSE,
    segment.color = "black"
  ) +
  scale_x_continuous(
    labels = comma,
    limits = c(0, 3000000)) +
  scale_y_continuous(
    labels = comma,
    limits = c(0, 350000)) +
  labs(
    x="Population",
    y="Estimated Number of Lives Saved"
    )+
  plot_theme
```

# New Cases by County

```{r County New 2,  fig.height=10, fig.width=20}
ggplot(data = nys, 
  aes(x=t, y=fct_reorder(county, I), fill = I)) +
  geom_raster(show.legend = TRUE) + 
  scale_fill_distiller(palette = "Spectral") +
  scale_x_date(date_breaks = "weeks", date_labels = "%b-%d") + 
  labs(x = "Date",
       y = NULL) +  
  guides(fill = guide_legend(title = "Cases")) +
  theme(
    plot.background = element_rect(fill = "linen"),
    panel.background = element_rect(fill = "linen"),
    strip.background = element_rect(fill = "grey80"),
    strip.text = element_text(color = "black"),
    legend.position = "right",
    legend.background = element_rect(fill = "linen"),
    panel.border = element_rect(
      colour = "black",
      fill = NA,
      size = 1
    ),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    plot.title = element_text(face="bold", size=rel(1.5), hjust=0),
    plot.subtitle = element_text()         
  ) +
  ggtitle(label = "New Cases by County", subtitle= "Heat Map")

ggplot(data = nys, 
  aes(x=t, y=fct_reorder(county, I),  height = I, fill = I)) +
  geom_ridgeline_gradient(show.legend = TRUE, scale = 0.005) + 
  scale_fill_distiller(palette = "Spectral") +
  labs(x = "Date",
       y = NULL) +  
  scale_x_date(date_breaks = "weeks", date_labels = "%b-%d") + 
  guides(fill = guide_legend(title = "Cases")) +  
  theme(
    panel.background = element_rect(fill = "linen"),
    panel.border = element_rect(
      colour = "black",
      fill = NA,
      size = 1
    ),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    plot.background = element_rect(fill = "linen"),
    plot.title = element_text(face="bold", size=rel(1.5), hjust=0),
    plot.subtitle = element_text(),
    strip.background = element_rect(fill = "grey80"),
    strip.text = element_text(color = "black"),
    legend.position = "right",
    legend.background = element_rect(fill = "linen")
  ) +
  ggtitle(label = "New Cases by County", subtitle= "Ridgeline Plot")  

nys %>%
  filter(county %in% c('Bronx', 'New York', 'Westchester', 'Kings', 'Queens', 'Suffolk', 'Nasssau', 'Richmond', 'Erie', 'Orange', 'Richmond')) %>%
ggplot(aes(x=t, y=fct_reorder(county, I),  height = I, fill = I)) +
  geom_ridgeline_gradient(show.legend = TRUE, scale = 0.001) + 
  scale_fill_distiller(palette = "Spectral") +
  labs(x = "Date",
       y = NULL) +  
  scale_x_date(date_breaks = "weeks", date_labels = "%b-%d") + 
  guides(fill = guide_legend(title = "Cases")) +
  theme(
    plot.background = element_rect(fill = "linen"),
    panel.background = element_rect(fill = "linen"),
    strip.background = element_rect(fill = "linen"),
    strip.text = element_text(color = "black"),
    legend.position = "right",
    legend.background = element_rect(fill = "linen"),
    panel.border = element_rect(
      colour = "black",
      fill = NA,
      size = 1
    ),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    plot.title = element_text(face="bold", size=rel(1.5), hjust=0),
    plot.subtitle = element_text()         
  ) +
  ggtitle(label = "New Cases by County - Top 10 Counties", subtitle= "Ridgeline Plot")  
```

#  Cummulative Cases by County

```{r County Cummualtive, fig.width=7.5, fig.height=10}
nys %>% 
  inner_join(NYpop, by=c("f" = "GEOID")) %>% 
  group_by(county) %>% 
  filter(t == max(t)) %>% 
  ggplot(aes(x=C/estimate, y=fct_reorder(county, C/estimate), size=estimate, color=estimate)) +
  geom_point() + 
  annotate(geom = "rect", 
           xmin = c(0, 0.01, .02, .03, .04),
           xmax = c(0.01, .02, .03, .04, .05),
           ymin = -Inf,
           ymax = Inf,
           fill = c(o_i_colors[1:5]),
           alpha = 0.1) +
  scale_x_continuous(labels = percent) +
  scale_size(labels = comma) + 
  scale_color_viridis_c(labels = comma) +
  labs(x = "Percentage of Population Infected", y=NULL) +
  guides(color = guide_legend(title = "Population"), 
         size = guide_legend(title = "Population")) +
  ggtitle(label = "Total Confirmed Cases by County", subtitle="Percent of Population") + 
plot_theme
```

# Percentage of Tests performed that were Positive by County

```{r County Percentage, fig.height=50, fig.width=20}
ggplot(data = nys) +
     geom_point(mapping = aes(x = t, y = I * 100 / T)) +
     geom_point(data = filter(nys, t == max(t)),
             mapping = aes(x = t, y = I*100/T),
             color = "red") +
#  geom_rect(
#    aes(
#      xmin = as.Date("2020-03-20"),
#      xmax = as.Date("2020-04-03"),
#      ymin = 0,
#      ymax = Inf
#    ),
#    fill = "gray100",
#    alpha = 0.01
#  ) +    
     geom_smooth(mapping = aes(x = t, y = I * 100 / T)) +
     geom_label_repel(
          data = filter(nys, t == max(t)),
          aes(
               x = t,
               y = I * 100 / T,
               label = sprintf("%.1f %%", I * 100 / T),
               fill="red"
          ),
          show.legend = FALSE,
          segment.color = "black",
          nudge_x = -10,
          nudge_y = 50
     ) +
     geom_ribbon(aes(ymin = 0,
                     ymax = T / 60,
                     x = t),
                 alpha = 0.3,
                 fill = "tomato") +
     scale_y_continuous(sec.axis = sec_axis(~ . * 60, name = "Total Tests Performed")) +
     geom_vline(xintercept = as.Date("2020-03-20"), linetype = 4) +
     geom_hline(yintercept = 0) +
     labs(x = "Date",
          y = "Percentage of Tests Performed that were Positive") +
     facet_wrap(~ county, ncol = 4) +
     ggtitle(label = "Percentage Positive by County", subtitle = "Number of Tests Performed") +
     theme(
          plot.background = element_rect(fill = "linen"),
          panel.background = element_rect(fill = "linen"),
          strip.background = element_rect(fill = "grey80"),
          strip.text = element_text(color = "black"),
          legend.position = "bottom",
          axis.text.y.right = element_text(color = "tomato"),
          axis.title.y.right = element_text(color = "tomato"),
          panel.border = element_rect(
               colour = "black",
               fill = NA,
               size = 1
          ),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          plot.title = element_text(face="bold", size=rel(1.5), hjust=0),        
          plot.subtitle = element_text(color = "tomato")
     )
```
\pagebreak

# Deaths by County. 

<p class="intro">New York City deaths are combined from New York, Bronx, Kings, Queens and Richmond counties.</p>

```{r County Deaths 1, fig.height=10, fig.width=20}
ggplot(data = NYCountyDeaths, 
  aes(x=date, y=fct_reorder(county, d), fill = d)) +
  geom_raster(show.legend = TRUE) + 
  scale_fill_distiller(palette = "Spectral") +
  scale_x_date(date_breaks = "weeks", date_labels = "%b-%d") + 
  labs(x = "Date",
       y = NULL) +  
  guides(fill = guide_legend(title = "Deaths")) +  
  theme(
    plot.background = element_rect(fill = "linen"),
    panel.background = element_rect(fill = "linen"),
    strip.background = element_rect(fill = "linen"),
    legend.background = element_rect(fill = "linen"),    
    strip.text = element_text(color = "black"),
    legend.position = "right",
    panel.border = element_rect(
      colour = "black",
      fill = NA,
      size = 1
    ),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    plot.title = element_text(face="bold", size=rel(1.5), hjust=0),
    plot.subtitle = element_text()         
  ) +
  ggtitle(label = "Deaths by County", subtitle= "Heat Map")

ggplot(data = NYCountyDeaths, 
  aes(x=date, y=fct_reorder(county, d),  height = d, fill = d)) +
  geom_ridgeline_gradient(show.legend = TRUE, scale = 0.01) + 
  scale_fill_distiller(palette = "Spectral") +
  scale_x_date(date_breaks = "weeks", date_labels = "%b-%d") + 
  labs(x = "Date",
       y = NULL) +  
  guides(fill = guide_legend(title = "Deaths")) +  
  theme(
    plot.background = element_rect(fill = "linen"),
    panel.background = element_rect(fill = "linen"),
    legend.background = element_rect(fill = "linen"),
    strip.background = element_rect(fill = "linen"),
    strip.text = element_text(color = "black"),
    legend.position = "right",
    panel.border = element_rect(
      colour = "black",
      fill = NA,
      size = 1
    ),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    plot.title = element_text(face="bold", size=rel(1.5), hjust=0),
    plot.subtitle = element_text()         
  ) +
  ggtitle(label = "Deaths by County", subtitle= "Ridgeline Plot")  
```

# Estimation of R<sub>t</sub> in New York State by County

<p class="intro">Counties with fewer than 11 cases per week, on average, do not have enough data to accurately estimate R<sub>t</sub>.  For those counties, R<sub>t</sub> and the 95% Confidence Interval are listed as NA.  On the map, they are left blank.</p>

```{r Counties R, fig.width=7.5, fig.height=10}
ggplot(ny_map4, aes(y=fct_reorder(County, R), x = R, size = Population, color = Population)) +
     geom_point() +  
     geom_pointrange(aes(xmin = Confl, 
                         xmax = Confh)) +
     annotate(geom = "rect", 
              xmin = c(0, 0.5, 1, 1.2, 1.5),
              xmax = c(0.5, 1, 1.2, 1.5, 2),
              ymin = -Inf,
              ymax = Inf,
              fill = c(o_i_colors[1:5]),
              alpha = 0.1) +
     scale_x_continuous(breaks = c(0.5, 1, 1.2, 1.5, 2)) +
     scale_size(labels = comma,
                breaks = c(1000, 5000, 10000,50000,100000,200000, 500000, 1000000, 2000000, 3000000),
                range = c(0.1,3)) + 
     scale_color_viridis_c(labels = comma,
                breaks = c(1000, 5000, 10000,50000,100000,200000, 500000, 1000000, 2000000, 3000000)) +
     labs(x = bquote(R[t]), y=NULL) +
     guides(color = guide_legend(), 
            size = guide_legend()) +
     ggtitle(label= bquote(R[t]), subtitle = "Estimation by County") +
     theme(
          rect = element_rect(fill = "linen"),
          panel.background = element_rect(fill = "linen"),
          strip.background = element_rect(fill = "linen"),
          plot.background = element_rect(fill = "linen"),
          legend.background = element_rect(fill = "linen"),
          panel.grid.minor = element_blank(),
          plot.title = element_text(face="bold", size=rel(1.5), hjust=0),
          plot.subtitle = element_text()             
     )    
```

# Map of R<sub>t</sub> in New York State by County

```{r NY Map R, fig.width= 20, fig.height=20}
ggplot(data = ny_map3) +
     geom_sf(aes(fill = R)) +
     scale_fill_stepsn(
          breaks = c(0.5, 1, 1.2, 1.5),
          colours = o_i_colors[2:8]) +
     labs(fill = bquote(R[t])) +
     geom_sf_text(aes(label = County, geometry=geometry)) +
     ylim(40, 46) +
     ggtitle(label = bquote(R[t]), subtitle="Estimation by County") +
     map_theme
```

# Estimation of R<sub>t</sub> in the United States by State

```{r States R, fig.width=7.8, fig.height=10}
ggplot(us_map4, aes(y=fct_reorder(State, R), x = R, size = Population, color = Population)) +
     geom_point() + 
     geom_pointrange(aes(xmin = Confl, 
                         xmax = Confh)) +
     annotate(geom = "rect", 
              xmin = c(0, 0.5, 1, 1.2, 1.5),
              xmax = c(0.5, 1, 1.2, 1.5, 2),
              ymin = -Inf,
              ymax = Inf,
              fill = c(o_i_colors[1:5]),
              alpha = 0.1) +
     scale_x_continuous(breaks = c(0.5, 1, 1.2, 1.5, 2)) +
     scale_size(labels = comma,
                breaks = c(1000000, 5000000, 10000000,20000000,30000000,40000000, 50000000),
                range = c(0.1,3)) + 
     scale_color_viridis_c(labels = comma,
                breaks = c(1000000, 5000000, 10000000,20000000,30000000,40000000, 50000000)) +  
     labs(x= bquote(R[t]), y=NULL) +
     guides(color = guide_legend(), 
            size = guide_legend()) +
     ggtitle(label = bquote(R[t]), subtitle = "Estimate by State") +
     theme(
          panel.background = element_rect(fill = "linen"),
          rect = element_rect(fill = "linen"),
          plot.background = element_rect(fill = "linen"),
          legend.background = element_rect(fill = "linen"),
          panel.grid.minor = element_blank(),
          plot.title = element_text(face="bold", size=rel(1.5), hjust=0),
          plot.subtitle = element_text()             
     )    
     
```

# Map of R<sub>t</sub> in the United States

```{r US Map R, fig.width= 18.7, fig.height=8.4}
ggplot(data = us_map48) +
     geom_sf(aes(fill = R, 
                 geometry = geometry)) +
     scale_fill_stepsn(
       breaks = c(0.5, 1, 1.2, 1.5),
       colours = o_i_colors[2:8] ) +
     geom_sf_text(aes(label = STUSPS, geometry=geometry)) +
     labs(fill = bquote(R[t])) +
     ggtitle(label =  bquote(R[t]), subtitle = "Estimation by State") + 
     map_theme +
     coord_sf()
```

\pagebreak

<footer>
  <h2 id="footnote-label">Footnotes</h2>
  <ol>
     <li id=#D1>New York State Department of Health data: https://health.data.ny.gov/resource/xdss-u53e.json </li>
     <li id=#D2>New York Times data: https://github.com/nytimes/covid-19-data </li>
     <li id="R">American Journal of Epidemiology
Vol. 178, No. 9 September 15, 2013
A New Framework and Software to Estimate Time-Varying ReproductionNumbers During Epidemics
  <a href="#R-ref" aria-label="Back to content">+</a></li>
      <li id="SI">Emerging Infectious Disease
Volume 26, Number 6—June 2020
Research Letter
Serial Interval of COVID-19 among Publicly Reported Confirmed Cases 
  <a href="#SI-ref" aria-label="Back to content">+</a></li>
  </ol>
</footer>
